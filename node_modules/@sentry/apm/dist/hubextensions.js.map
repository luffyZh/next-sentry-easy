{"version":3,"file":"hubextensions.js","sourceRoot":"","sources":["../src/hubextensions.ts"],"names":[],"mappings":";AAAA,mCAAkD;AAElD,uCAA6C;AAE7C,+BAA8B;AAE9B;;;GAGG;AACH,SAAS,cAAc,CAAC,IAAa;IACnC,OAAO,oBAAY,CAAC,IAAI,EAAE,WAAI,CAAC,CAAC;AAClC,CAAC;AAED,qEAAqE;AACrE,SAAS,YAAY;IACnB,aAAa;IACb,IAAM,IAAI,GAAG,IAAW,CAAC;IACzB,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;IAC9B,IAAI,KAAK,EAAE;QACT,IAAM,IAAI,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC;QAC7B,IAAI,IAAI,EAAE;YACR,OAAO;gBACL,cAAc,EAAE,IAAI,CAAC,aAAa,EAAE;aACrC,CAAC;SACH;KACF;IACD,OAAO,EAAE,CAAC;AACZ,CAAC;AAED;;;;;;GAMG;AACH,SAAS,SAAS,CAAC,iBAAsC,EAAE,YAA6B;IAA7B,6BAAA,EAAA,oBAA6B;IACtF,aAAa;IACb,IAAM,IAAI,GAAG,IAAW,CAAC;IACzB,IAAM,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;IAC9B,IAAM,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;IAChC,IAAI,IAAI,CAAC;IAET,IAAI,CAAC,cAAc,CAAC,iBAAiB,CAAC,IAAI,CAAC,YAAY,EAAE;QACvD,IAAI,KAAK,EAAE;YACT,IAAM,UAAU,GAAG,KAAK,CAAC,OAAO,EAAU,CAAC;YAC3C,IAAI,UAAU,EAAE;gBACd,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;aAC5C;SACF;KACF;IAED,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE;QACzB,IAAI,GAAG,IAAI,WAAI,CAAC,iBAAiB,EAAE,IAAI,CAAC,CAAC;KAC1C;IAED,IAAI,IAAI,CAAC,OAAO,KAAK,SAAS,IAAI,IAAI,CAAC,WAAW,KAAK,SAAS,EAAE;QAChE,IAAM,UAAU,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;QACzE,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,UAAU,CAAC;KAC3C;IAED,IAAI,IAAI,CAAC,OAAO,EAAE;QAChB,IAAM,kBAAkB,GAAG,CAAC,MAAM,IAAI,MAAM,CAAC,UAAU,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QAC9E,IAAI,CAAC,iBAAiB,CAAC,kBAAkB,CAAC,QAAkB,CAAC,CAAC;KAC/D;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;GAEG;AACH,SAAgB,mBAAmB;IACjC,IAAM,OAAO,GAAG,oBAAc,EAAE,CAAC;IACjC,IAAI,OAAO,CAAC,UAAU,EAAE;QACtB,OAAO,CAAC,UAAU,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC,UAAU,IAAI,EAAE,CAAC;QACpE,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,EAAE;YAC5C,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,SAAS,GAAG,SAAS,CAAC;SACrD;QACD,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,YAAY,EAAE;YAC/C,OAAO,CAAC,UAAU,CAAC,UAAU,CAAC,YAAY,GAAG,YAAY,CAAC;SAC3D;KACF;AACH,CAAC;AAXD,kDAWC","sourcesContent":["import { getMainCarrier, Hub } from '@sentry/hub';\nimport { SpanContext } from '@sentry/types';\nimport { isInstanceOf } from '@sentry/utils';\n\nimport { Span } from './span';\n\n/**\n * Checks whether given value is instance of Span\n * @param span value to check\n */\nfunction isSpanInstance(span: unknown): span is Span {\n  return isInstanceOf(span, Span);\n}\n\n/** Returns all trace headers that are currently on the top scope. */\nfunction traceHeaders(): { [key: string]: string } {\n  // @ts-ignore\n  const that = this as Hub;\n  const scope = that.getScope();\n  if (scope) {\n    const span = scope.getSpan();\n    if (span) {\n      return {\n        'sentry-trace': span.toTraceparent(),\n      };\n    }\n  }\n  return {};\n}\n\n/**\n * This functions starts a span. If argument passed is of type `Span`, it'll run sampling on it if configured\n * and attach a `SpanRecorder`. If it's of type `SpanContext` and there is already a `Span` on the Scope,\n * the created Span will have a reference to it and become it's child. Otherwise it'll crete a new `Span`.\n *\n * @param span Already constructed span which should be started or properties with which the span should be created\n */\nfunction startSpan(spanOrSpanContext?: Span | SpanContext, forceNoChild: boolean = false): Span {\n  // @ts-ignore\n  const that = this as Hub;\n  const scope = that.getScope();\n  const client = that.getClient();\n  let span;\n\n  if (!isSpanInstance(spanOrSpanContext) && !forceNoChild) {\n    if (scope) {\n      const parentSpan = scope.getSpan() as Span;\n      if (parentSpan) {\n        span = parentSpan.child(spanOrSpanContext);\n      }\n    }\n  }\n\n  if (!isSpanInstance(span)) {\n    span = new Span(spanOrSpanContext, that);\n  }\n\n  if (span.sampled === undefined && span.transaction !== undefined) {\n    const sampleRate = (client && client.getOptions().tracesSampleRate) || 0;\n    span.sampled = Math.random() < sampleRate;\n  }\n\n  if (span.sampled) {\n    const experimentsOptions = (client && client.getOptions()._experiments) || {};\n    span.initFinishedSpans(experimentsOptions.maxSpans as number);\n  }\n\n  return span;\n}\n\n/**\n * This patches the global object and injects the APM extensions methods\n */\nexport function addExtensionMethods(): void {\n  const carrier = getMainCarrier();\n  if (carrier.__SENTRY__) {\n    carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};\n    if (!carrier.__SENTRY__.extensions.startSpan) {\n      carrier.__SENTRY__.extensions.startSpan = startSpan;\n    }\n    if (!carrier.__SENTRY__.extensions.traceHeaders) {\n      carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;\n    }\n  }\n}\n"]}